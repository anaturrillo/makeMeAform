{"version":3,"sources":["memoise-decorators.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,0BAA0B,QAAQ,gDAAR,EAA0D,SAA1D,CAA1B;;AAEJ,QAAQ,UAAR,GAAqB,IAArB;;AAEA,IAAI,cAAc,QAAQ,aAAR,CAAd;;AAEJ,IAAI,IAAI,wBAAwB,WAAxB,CAAJ;;AAEJ,QAAQ,SAAR,IAAqB,UAAU,UAAV,EAAsB,KAAtB,EAA6B;AAChD,OAAK,IAAI,KAAK,CAAL,EAAQ,KAAK,WAAW,MAAX,EAAmB,IAAzC,EAA+C;AAC7C,QAAI,YAAY,WAAW,EAAX,CAAZ,CADyC;AAE7C,QAAI,aAAa,UAAU,UAAV,CAF4B;AAG7C,QAAI,CAAC,EAAE,kBAAF,CAAqB,UAArB,CAAD,EAAmC,SAAvC;;AAEA,QAAI,OAAO,MAAM,qBAAN,CAA4B,WAAW,MAAX,CAAnC,CALyC;AAM7C,QAAI,MAAM,SAAN,CANyC;;AAQ7C,QAAI,QAAQ,EAAR,CARyC;;AAU7C,QAAI,IAAJ,EAAU;AACR,YAAM,IAAN,CADQ;AAER,YAAM,IAAN,CAAW,EAAE,oBAAF,CAAuB,GAAvB,EAA4B,IAA5B,EAAkC,WAAW,MAAX,CAA7C,EAFQ;KAAV,MAGO;AACL,YAAM,WAAW,MAAX,CADD;KAHP;;AAOA,UAAM,IAAN,CAAW,EAAE,cAAF,CAAiB,EAAE,gBAAF,CAAmB,EAAE,gBAAF,CAAmB,GAAnB,EAAwB,WAAW,QAAX,EAAqB,WAAW,QAAX,CAAhE,EAAsF,EAAE,UAAF,CAAa,MAAb,CAAtF,CAAjB,EAA8H,CAAC,GAAD,CAA9H,CAAX,EAjB6C;;AAmB7C,QAAI,MAAM,MAAN,KAAiB,CAAjB,EAAoB;AACtB,gBAAU,UAAV,GAAuB,MAAM,CAAN,CAAvB,CADsB;KAAxB,MAEO;AACL,gBAAU,UAAV,GAAuB,EAAE,kBAAF,CAAqB,KAArB,CAAvB,CADK;KAFP;GAnBF;;AA0BA,SAAO,UAAP,CA3BgD;CAA7B;;AA8BrB,OAAO,OAAP,GAAiB,QAAQ,SAAR,CAAjB","file":"memoise-decorators-compiled.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nexports[\"default\"] = function (decorators, scope) {\n  for (var _i = 0; _i < decorators.length; _i++) {\n    var decorator = decorators[_i];\n    var expression = decorator.expression;\n    if (!t.isMemberExpression(expression)) continue;\n\n    var temp = scope.maybeGenerateMemoised(expression.object);\n    var ref = undefined;\n\n    var nodes = [];\n\n    if (temp) {\n      ref = temp;\n      nodes.push(t.assignmentExpression(\"=\", temp, expression.object));\n    } else {\n      ref = expression.object;\n    }\n\n    nodes.push(t.callExpression(t.memberExpression(t.memberExpression(ref, expression.property, expression.computed), t.identifier(\"bind\")), [ref]));\n\n    if (nodes.length === 1) {\n      decorator.expression = nodes[0];\n    } else {\n      decorator.expression = t.sequenceExpression(nodes);\n    }\n  }\n\n  return decorators;\n};\n\nmodule.exports = exports[\"default\"];"]}