{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["/* eslint max-len: 0 */\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\n\nvar _babelHelperGetFunctionArity = require(\"babel-helper-get-function-arity\");\n\nvar _babelHelperGetFunctionArity2 = _interopRequireDefault(_babelHelperGetFunctionArity);\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar buildPropertyMethodAssignmentWrapper = _babelTemplate2[\"default\"](\"\\n  (function (FUNCTION_KEY) {\\n    function FUNCTION_ID() {\\n      return FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    }\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\n\nvar buildGeneratorPropertyMethodAssignmentWrapper = _babelTemplate2[\"default\"](\"\\n  (function (FUNCTION_KEY) {\\n    function* FUNCTION_ID() {\\n      return yield* FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    };\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\n\nvar visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\": function ReferencedIdentifierBindingIdentifier(path, state) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n\n    // check that we don't have a local variable declared as that removes the need\n    // for the wrapper\n    var localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n\n    state.selfReference = true;\n    path.stop();\n  }\n};\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      // we can just munge the local binding\n      scope.rename(id.name);\n    } else {\n      // we don't currently support wrapping class expressions\n      if (!t.isFunction(method)) return;\n\n      // need to add a wrapper since we can't change the references\n      var build = buildPropertyMethodAssignmentWrapper;\n      if (method.generator) build = buildGeneratorPropertyMethodAssignmentWrapper;\n      var _template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      _template.callee._skipModulesRemap = true;\n\n      // shim in dummy params to retain function arity, if you try to read the\n      // source then you'll get the original since it's proxied so it's all good\n      var params = _template.callee.body.body[0].params;\n      for (var i = 0, len = _babelHelperGetFunctionArity2[\"default\"](method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return _template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  var state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  var binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.selfReference = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n      scope.traverse(node, visitor, state);\n    }\n\n  return state;\n}\n\nexports[\"default\"] = function (_ref) {\n  var node = _ref.node;\n  var parent = _ref.parent;\n  var scope = _ref.scope;\n  var id = _ref.id;\n\n  // has an `id` so we don't need to infer one\n  if (node.id) return;\n\n  if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, { kind: \"method\" })) && (!parent.computed || t.isLiteral(parent.key))) {\n    // { foo() {} };\n    id = parent.key;\n  } else if (t.isVariableDeclarator(parent)) {\n    // let foo = function () {};\n    id = parent.id;\n\n    if (t.isIdentifier(id)) {\n      var binding = scope.parent.getBinding(id.name);\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        // always going to reference this method\n        node.id = id;\n        node.id[t.NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (t.isAssignmentExpression(parent)) {\n    // foo = function () {};\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  var name = undefined;\n  if (id && t.isLiteral(id)) {\n    name = id.value;\n  } else if (id && t.isIdentifier(id)) {\n    name = id.name;\n  } else {\n    return;\n  }\n\n  name = t.toBindingIdentifierName(name);\n  id = t.identifier(name);\n\n  // The id shouldn't be considered a local binding to the function because\n  // we are simply trying to set the function name and not actually create\n  // a local binding.\n  id[t.NOT_LOCAL_BINDING] = true;\n\n  var state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n};\n\nmodule.exports = exports[\"default\"];"]}